import scala.io.StdIn

import java.net.{NetworkInterface, InetAddress}

import Client._
import akka.actor.{ActorSystem, Props}
import com.typesafe.config.{ConfigFactory, Config}

import scala.collection.immutable.Map
import scala.collection.JavaConverters._

object App {
    def main(args: Array[String]): Unit = {
        println("Shooter Multiplayer")
        println("1. Client")
        println("2. Server")
        println("3. Exit")
        val choice: Int = getValidInput()

        val ip: String = getIpFromList()
        var serverport: String = "0"
        if (choice equals 2) serverport = StdIn.readLine("Enter Port: ")
        
        val system = ActorSystem("shooter", getConfig(ip, serverport))
        val clientRef = system.actorOf(Props[Client], "client")
        val serverRef = system.actorOf(Props[Server], "server")
        
        choice match {
            case 1 => {
                println("Connect to server")
                val ip: String = StdIn.readLine("Enter IP: ")
                val port: String = StdIn.readLine("Enter Port: ")

                clientRef ! StartJoin(ip, port)
            }

            case 2 => {
                val inetAddress: InetAddress = InetAddress.getLocalHost
                val ip: String = inetAddress.getHostAddress

                clientRef ! StartJoin(ip, serverport)
                serverRef ! Server.Start
                println(s"Listening on $ip : $serverport")
            }

            case 3 | _ => sys.exit()
        }
    }

    private def getIpFromList(): String = {
        var count = 0
        val addresses: Map[Int, InetAddress] = (for (inf <- NetworkInterface.getNetworkInterfaces.asScala; add <- inf.getInetAddresses.asScala) yield { 
            count += 1; (count -> add) 
        }).toMap

        println(addresses)

        for ((i, add) <- addresses) {
            println(add.toString)
            println(s"$i = $add")
        }

        println("Please select which interface to bind")
        var selection: Int = 0
        do {
            selection = StdIn.readInt()
        } while (!((selection >= 0) && (selection < addresses.size)))

        return addresses(selection).getHostAddress
    }

    private def getValidInput(): Int = {
        val invalid = (x: Int) => (x != 1) && (x != 2) && (x != 3)
        var exceptionThrown = false
        var input: Int = Int.MaxValue

        while (invalid(input)) {
            try {
                input = StdIn.readLine("Choice: ").toInt
            } catch {
                case _: NumberFormatException => exceptionThrown = true
            }

            if (invalid(input) || exceptionThrown) println("Enter a valid input") else return input
        }

        return 1
    }

    private def getConfig(hostname: String, port: String = "0"): Config = {
        println("Binding to: " + hostname)
        val config = ConfigFactory.parseString(s"""
            |  akka {
            |    loglevel = "INFO"
            |  
            |    actor {
            |      provider = "akka.remote.RemoteActorRefProvider"
            |      serializers {
            |          java = "akka.serialization.JavaSerializer"
            |          proto = "akka.remote.serialization.ProtobufSerializer"
            |          custom = "serialization.CustomSerializer"
            |      }
            |  
            |      serialization-bindings {
            |          "game.GameState" = custom
            |      }
            |    }
            |  
            |    remote {
            |      enabled-transports = ["akka.remote.netty.tcp"]
            |      netty.tcp {
            |        hostname = "$hostname"
            |        port = $port
            |      }
            |  
            |      log-sent-messages = on
            |      log-received-messages = on
            |    }
            |  
            |  }
            |  
        """.stripMargin)

        println("REACH")

        return config.withFallback(ConfigFactory.load())
    }
}